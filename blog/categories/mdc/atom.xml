<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MDC | yann's Blog]]></title>
  <link href="http://yanns.github.io/blog/categories/mdc/atom.xml" rel="self"/>
  <link href="http://yanns.github.io/"/>
  <updated>2014-08-12T18:10:48+02:00</updated>
  <id>http://yanns.github.io/</id>
  <author>
    <name><![CDATA[Yann Simon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SLF4J Mapped Diagnostic Context (MDC) with play framework]]></title>
    <link href="http://yanns.github.io/blog/2014/05/04/slf4j-mapped-diagnostic-context-mdc-with-play-framework/"/>
    <updated>2014-05-04T11:45:52+02:00</updated>
    <id>http://yanns.github.io/blog/2014/05/04/slf4j-mapped-diagnostic-context-mdc-with-play-framework</id>
    <content type="html"><![CDATA[<p>I&rsquo;d like the share with this post one solution I found to use a Mapped Diagnostic Context (MDC) in an asynchronous environment like the play framework.</p>

<h2>tl;dr</h2>

<p>This solution uses a custom <code>ExecutionContext</code> that propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one.
A custom <code>ActionBuilder</code> is necessary as well to completely use this custom <code>ExectionContext</code>.</p>

<h2>The Mapped Diagnostic Context (MDC)</h2>

<p>The play framework uses for logging <a href="http://logback.qos.ch/">Logback</a> behind <a href="http://www.slf4j.org/">SLF4J (&ldquo;Simple Logging Facade for Java&rdquo;)</a>.<br/>
This library provides a convenient feature: the <a href="http://logback.qos.ch/manual/mdc.html">Mapped Diagnostic Context (MDC)</a>.
This context can be used to store values that can be displayed in every Logging statement.<br/>
For example, if we want to display the current user ID:
```scala</p>

<pre><code>import org.slf4j.MDC

val id = currentUser.id
MDC.put("X-UserId", currentUser.id)

try {
  // the block of code that uses the Logger
  // for example:
  play.api.Logger.info("test")
} finally {
  // clean up the MDC
  MDC.remove("X-UserId")
}
</code></pre>

<p>```
(This code could be in a <a href="http://www.playframework.com/documentation/2.2.x/ScalaHttpFilters">filter</a>, run for each request)</p>

<p>Logback must be configured to display the <code>X-UserId</code> value:
```xml</p>

<pre><code>&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %coloredLevel %logger{35} %mdc{X-UserId:--} - %msg%n%rootException&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre>

<p><code>
In the log file, the MDC value for `X-UserId` is now printed out.
</code>
10:50:54.773 [info] application jean.leloup &ndash; test
```</p>

<h2>Limitation of the default implementation of the MDC</h2>

<p>To record the values in the MDC, Logback uses a <code>ThreadLocal</code> variable.
This strategy works when one thread is used for one request, like in servlet container before the 3.1 specification.</p>

<p>Play framework, on the other hand, is <a href="http://www.playframework.com/documentation/2.2.x/ScalaAsync">asynchronous</a>. The processing of a request is composed of several function calls, and each call can be run on a different thread. (&ldquo;Don&rsquo;t call me, I&rsquo;ll call you&rdquo;)</p>

<p>The implementation of the MDC with a <code>ThreadLocal</code> cannot work with this non-blocking asynchronous threading model.</p>

<h2>Defining a custom execution context</h2>

<p>The dispatching of the jobs on different threads in done with an <code>ExecutionContext</code>. Each <code>ExecutionContext</code> manages a <a href="http://www.playframework.com/documentation/2.2.x/ThreadPools">thread pool</a>.</p>

<p>To use the MDC, we just have to use a custom <code>ExecutionContext</code> that propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one.
```scala
import org.slf4j.MDC
import scala.concurrent.{ExecutionContextExecutor, ExecutionContext}</p>

<p>/<em>*
 * slf4j provides a MDC [[<a href="http://logback.qos.ch/manual/mdc.html">http://logback.qos.ch/manual/mdc.html</a> Mapped Diagnostic Context]]
 * based on a [[ThreadLocal]]. In an asynchronous environment, the callbacks can be called
 * in another thread, where the local thread variable does not exist anymore.
 *
 * This execution context fixes this problem:
 * it propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one.
 </em>/
object MDCHttpExecutionContext {</p>

<p>  /<em>*
   * Create an MDCHttpExecutionContext with values from the current thread.
   </em>/
  def fromThread(delegate: ExecutionContext): ExecutionContextExecutor =</p>

<pre><code>new MDCHttpExecutionContext(MDC.getCopyOfContextMap, delegate)
</code></pre>

<p>}</p>

<p>/<em>*
 * Manages execution to ensure that the given MDC context are set correctly
 * in the current thread. Actual execution is performed by a delegate ExecutionContext.
 </em>/
class MDCHttpExecutionContext(mdcContext: java.util.Map[<em>, </em>], delegate: ExecutionContext) extends ExecutionContextExecutor {
  def execute(runnable: Runnable) = delegate.execute(new Runnable {</p>

<pre><code>def run() {
  val oldMDCContext = MDC.getCopyOfContextMap
  setContextMap(mdcContext)
  try {
    runnable.run()
  } finally {
    setContextMap(oldMDCContext)
  }
}
</code></pre>

<p>  })</p>

<p>  private[this] def setContextMap(context: java.util.Map[<em>, </em>]) {</p>

<pre><code>if (context == null) {
  MDC.clear()
} else {
  MDC.setContextMap(context)
}
</code></pre>

<p>  }</p>

<p>  def reportFailure(t: Throwable) = delegate.reportFailure(t)
}
```</p>

<p>Then we can define the default ExecutionContext in our application:
```scala
package concurrent</p>

<p>import scala.concurrent.ExecutionContext</p>

<p>/<em>*
 * The standard [[play.api.libs.concurrent.Execution.defaultContext]] loses the MDC context.
 *
 * This custom [[ExecutionContext]] propagates the MDC context, so that the request
 * and the correlation IDs can be logged.
 </em>/
object Execution {</p>

<p>  object Implicits {</p>

<pre><code>implicit def defaultContext: ExecutionContext = Execution.defaultContext
</code></pre>

<p>  }</p>

<p>  def defaultContext: ExecutionContext = MDCHttpExecutionContext.fromThread(play.api.libs.concurrent.Execution.defaultContext)</p>

<p>}
```</p>

<p>Now we will use the <code>concurrent.Execution.defaultContext</code> instead of the one from play (<code>play.api.libs.concurrent.Execution.defaultContext</code>)</p>

<h2>Using a custom execution context everywhere</h2>

<p>Using a custom execution context is sometimes as easy as replacing
<code>import play.api.libs.concurrent.Execution.Implicits._</code> with <code>import concurrent.Execution.Implicits._</code></p>

<p>The default <a href="http://www.playframework.com/documentation/2.2.x/ScalaActions"><code>Action</code></a> uses the default <code>play.api.libs.concurrent.Execution.defaultContext</code>.
We must define a custom <code>ActionBuilder</code> that uses our new <code>ExecutionContext</code>:
```scala
package controllers</p>

<p>object Action extends ActionBuilder[Request] {
  def invokeBlock<a href="request:%20Request[A],%20block:%20(Request[A]">A</a> => Future[SimpleResult]) = {</p>

<pre><code>block(request)
</code></pre>

<p>  }</p>

<p>  /<em>*
   * The standard [[play.api.mvc.Action]] loses the MDC context.
   *
   * This action builder sets the [[ExecutionContext]] so that the
   * MDC context is propagated.
   * With this custom [[ExecutionContext]], the request and the correlation IDs
   * can be logged.
   </em>/
  override def executionContext: ExecutionContext = Execution.defaultContext
}
```</p>

<p>Instead of using of <code>play.api.mvc.Action</code>, we just have to use the newly defined <code>controllers.Action</code>.</p>

<p>With these customizations, we are now able to use the Mapped Diagnostic Context (MDC) with asynchronous actions written in Scala.</p>
]]></content>
  </entry>
  
</feed>
