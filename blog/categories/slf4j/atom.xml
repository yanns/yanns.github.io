<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SLF4J | yann's Blog]]></title>
  <link href="http://yanns.github.io/blog/categories/slf4j/atom.xml" rel="self"/>
  <link href="http://yanns.github.io/"/>
  <updated>2015-12-11T10:59:37+01:00</updated>
  <id>http://yanns.github.io/</id>
  <author>
    <name><![CDATA[Yann Simon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SLF4J Mapped Diagnostic Context (MDC) with play framework]]></title>
    <link href="http://yanns.github.io/blog/2014/05/04/slf4j-mapped-diagnostic-context-mdc-with-play-framework/"/>
    <updated>2014-05-04T11:45:52+02:00</updated>
    <id>http://yanns.github.io/blog/2014/05/04/slf4j-mapped-diagnostic-context-mdc-with-play-framework</id>
    <content type="html"><![CDATA[<p>I&rsquo;d like the share with this post one solution I found to use a Mapped Diagnostic Context (MDC) in an asynchronous environment like the play framework.</p>

<h2>Edit (September 2014)</h2>

<p>Based on <a href="https://github.com/jroper/thread-local-context-propagation/">one implementation from James Roper</a>, I added one solution based on <a href="http://doc.akka.io/docs/akka/current/scala/dispatchers.html">Akka Dispatcher</a>.</p>

<h2>tl;dr</h2>

<p>This post provides two solution to propagate the MDC context in an asynchronous Play application:</p>

<ul>
<li>using a custom Akka <code>Dispatcher</code>. This solution needs minimal change to a current application.</li>
<li>using a custom <code>ExecutionContext</code> that propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one. A custom <code>ActionBuilder</code> is necessary as well to completely use this custom <code>ExectionContext</code>.</li>
</ul>


<h2>The Mapped Diagnostic Context (MDC)</h2>

<p>The play framework uses for logging <a href="http://logback.qos.ch/">Logback</a> behind <a href="http://www.slf4j.org/">SLF4J (&ldquo;Simple Logging Facade for Java&rdquo;)</a>.<br/>
This library provides a convenient feature: the <a href="http://logback.qos.ch/manual/mdc.html">Mapped Diagnostic Context (MDC)</a>.
This context can be used to store values that can be displayed in every Logging statement.<br/>
For example, if we want to display the current user ID:
```scala</p>

<pre><code>import org.slf4j.MDC

val id = currentUser.id
MDC.put("X-UserId", currentUser.id)

try {
  // the block of code that uses the Logger
  // for example:
  play.api.Logger.info("test")
} finally {
  // clean up the MDC
  MDC.remove("X-UserId")
}
</code></pre>

<p>```
(This code could be in a <a href="https://www.playframework.com/documentation/latest/ScalaHttpFilters">filter</a>, run for each request)</p>

<p>Logback must be configured to display the <code>X-UserId</code> value:
```xml</p>

<pre><code>&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt;
    &lt;encoder&gt;
        &lt;pattern&gt;%d{HH:mm:ss.SSS} %coloredLevel %logger{35} %mdc{X-UserId:--} - %msg%n%rootException&lt;/pattern&gt;
    &lt;/encoder&gt;
&lt;/appender&gt;
</code></pre>

<p><code>
In the log file, the MDC value for `X-UserId` is now printed out.
</code>
10:50:54.773 [info] application jean.leloup &ndash; test
```</p>

<h2>Limitation of the default implementation of the MDC</h2>

<p>To record the values in the MDC, Logback uses a <code>ThreadLocal</code> variable.
This strategy works when one thread is used for one request, like in servlet container before the 3.1 specification.</p>

<p>Play framework, on the other hand, is <a href="http://www.playframework.com/documentation/2.2.x/ScalaAsync">asynchronous</a>. The processing of a request is composed of several function calls, and each call can be run on a different thread. (&ldquo;Don&rsquo;t call me, I&rsquo;ll call you&rdquo;)</p>

<p>The implementation of the MDC with a <code>ThreadLocal</code> cannot work with this non-blocking asynchronous threading model.</p>

<h2>First solution with Akka Dispatcher</h2>

<h4>Defining a custom Akka dispatcher</h4>

<p>Play dispatchs the jobs on different threads with a <a href="https://www.playframework.com/documentation/latest/ThreadPools">thread pool</a>. The Play default thread pool is an <a href="http://doc.akka.io/docs/akka/current/scala/dispatchers.html">Akka dispatcher</a>.</p>

<p>To use the MDC, we provide a custom Akka <code>Dispatcher</code> that propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one.

```scala
package monitoring</p>

<p>import java.util.concurrent.TimeUnit</p>

<p>import akka.dispatch._
import com.typesafe.config.Config
import org.slf4j.MDC</p>

<p>import scala.concurrent.ExecutionContext
import scala.concurrent.duration.{Duration, FiniteDuration}</p>

<p>/<em>*
 * Configurator for a MDC propagating dispatcher.
 *
 * To use it, configure play like this:
 * {{{
 * play {
 *   akka {
 *     actor {
 *       default-dispatcher = {
 *         type = &ldquo;monitoring.MDCPropagatingDispatcherConfigurator&rdquo;
 *       }
 *     }
 *   }
 * }
 * }}}
 *
 * Credits to James Roper for the [[<a href="https://github.com/jroper/thread-local-context-propagation/">https://github.com/jroper/thread-local-context-propagation/</a> initial implementation]]
 </em>/
class MDCPropagatingDispatcherConfigurator(config: Config, prerequisites: DispatcherPrerequisites)
  extends MessageDispatcherConfigurator(config, prerequisites) {</p>

<p>  private val instance = new MDCPropagatingDispatcher(</p>

<pre><code>this,
config.getString("id"),
config.getInt("throughput"),
FiniteDuration(config.getDuration("throughput-deadline-time", TimeUnit.NANOSECONDS), TimeUnit.NANOSECONDS),
configureExecutor(),
FiniteDuration(config.getDuration("shutdown-timeout", TimeUnit.MILLISECONDS), TimeUnit.MILLISECONDS))
</code></pre>

<p>  override def dispatcher(): MessageDispatcher = instance
}</p>

<p>/<em>*
 * A MDC propagating dispatcher.
 *
 * This dispatcher propagates the MDC current request context if it&rsquo;s set when it&rsquo;s executed.
 </em>/
class MDCPropagatingDispatcher(_configurator: MessageDispatcherConfigurator,</p>

<pre><code>                           id: String,
                           throughput: Int,
                           throughputDeadlineTime: Duration,
                           executorServiceFactoryProvider: ExecutorServiceFactoryProvider,
                           shutdownTimeout: FiniteDuration)
</code></pre>

<p>  extends Dispatcher(_configurator, id, throughput, throughputDeadlineTime, executorServiceFactoryProvider, shutdownTimeout ) {</p>

<p>  self =></p>

<p>  override def prepare(): ExecutionContext = new ExecutionContext {</p>

<pre><code>// capture the MDC
val mdcContext = MDC.getCopyOfContextMap

def execute(r: Runnable) = self.execute(new Runnable {
  def run() = {
    // backup the callee MDC context
    val oldMDCContext = MDC.getCopyOfContextMap

    // Run the runnable with the captured context
    setContextMap(mdcContext)
    try {
      r.run()
    } finally {
      // restore the callee MDC context
      setContextMap(oldMDCContext)
    }
  }
})
def reportFailure(t: Throwable) = self.reportFailure(t)
</code></pre>

<p>  }</p>

<p>  private[this] def setContextMap(context: java.util.Map[String, String]) {</p>

<pre><code>if (context == null) {
  MDC.clear()
} else {
  MDC.setContextMap(context)
}
</code></pre>

<p>  }</p>

<p>}
```
</p>

<h4>Using a custom Akka dispatcher everywhere:</h4>

<p>To use this custom Akka dispatcher everywhere, we just have to configure it:
```bash application.conf
play {
  akka {</p>

<pre><code>actor {
  default-dispatcher = {
    type = "monitoring.MDCPropagatingDispatcherConfigurator"
  }
}
</code></pre>

<p>  }
}
```
and that&rsquo;s all! ;)</p>

<p>The MDC context is propagated when we use the play default <a href="https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.libs.concurrent.Execution$"><code>ExecutionContext</code></a>.</p>

<h4>Optimization</h4>

<p>So that this approach works in dev mode, simply make a library (jar) of this custom Akka dispatcher and add this as dependency in your play application.</p>

<h2>Second solution with a custom execution context</h2>

<h4>Defining a custom execution context</h4>

<p>The dispatching of the jobs on different threads in done with an <code>ExecutionContext</code>. Each <code>ExecutionContext</code> manages a <a href="https://www.playframework.com/documentation/latest/ThreadPools">thread pool</a>.</p>

<p>To use the MDC, we just have to use a custom <code>ExecutionContext</code> that propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one.
```scala
import org.slf4j.MDC
import scala.concurrent.{ExecutionContextExecutor, ExecutionContext}</p>

<p>/<em>*
 * slf4j provides a MDC [[<a href="http://logback.qos.ch/manual/mdc.html">http://logback.qos.ch/manual/mdc.html</a> Mapped Diagnostic Context]]
 * based on a [[ThreadLocal]]. In an asynchronous environment, the callbacks can be called
 * in another thread, where the local thread variable does not exist anymore.
 *
 * This execution context fixes this problem:
 * it propagates the MDC from the caller&rsquo;s thread to the callee&rsquo;s one.
 </em>/
object MDCHttpExecutionContext {</p>

<p>  /<em>*
   * Create an MDCHttpExecutionContext with values from the current thread.
   </em>/
  def fromThread(delegate: ExecutionContext): ExecutionContextExecutor =</p>

<pre><code>new MDCHttpExecutionContext(MDC.getCopyOfContextMap, delegate)
</code></pre>

<p>}</p>

<p>/<em>*
 * Manages execution to ensure that the given MDC context are set correctly
 * in the current thread. Actual execution is performed by a delegate ExecutionContext.
 </em>/
class MDCHttpExecutionContext(mdcContext: java.util.Map[<em>, </em>], delegate: ExecutionContext) extends ExecutionContextExecutor {
  def execute(runnable: Runnable) = delegate.execute(new Runnable {</p>

<pre><code>def run() {
  val oldMDCContext = MDC.getCopyOfContextMap
  setContextMap(mdcContext)
  try {
    runnable.run()
  } finally {
    setContextMap(oldMDCContext)
  }
}
</code></pre>

<p>  })</p>

<p>  private[this] def setContextMap(context: java.util.Map[<em>, </em>]) {</p>

<pre><code>if (context == null) {
  MDC.clear()
} else {
  MDC.setContextMap(context)
}
</code></pre>

<p>  }</p>

<p>  def reportFailure(t: Throwable) = delegate.reportFailure(t)
}
```</p>

<p>Then we can define the default ExecutionContext in our application:
```scala
package concurrent</p>

<p>import scala.concurrent.ExecutionContext</p>

<p>/<em>*
 * The standard [[play.api.libs.concurrent.Execution.defaultContext]] loses the MDC context.
 *
 * This custom [[ExecutionContext]] propagates the MDC context, so that the request
 * and the correlation IDs can be logged.
 </em>/
object Execution {</p>

<p>  object Implicits {</p>

<pre><code>implicit def defaultContext: ExecutionContext = Execution.defaultContext
</code></pre>

<p>  }</p>

<p>  def defaultContext: ExecutionContext = MDCHttpExecutionContext.fromThread(play.api.libs.concurrent.Execution.defaultContext)</p>

<p>}
```</p>

<p>Now we will use the <code>concurrent.Execution.defaultContext</code> instead of the one from play (<code>play.api.libs.concurrent.Execution.defaultContext</code>)</p>

<h4>Using a custom execution context everywhere</h4>

<p>Using a custom execution context is sometimes as easy as replacing
<code>import play.api.libs.concurrent.Execution.Implicits._</code> with <code>import concurrent.Execution.Implicits._</code></p>

<p>The default <a href="https://www.playframework.com/documentation/latest/ScalaActions"><code>Action</code></a> uses the default <code>play.api.libs.concurrent.Execution.defaultContext</code>.
We must define a custom <code>ActionBuilder</code> that uses our new <code>ExecutionContext</code>:
```scala
package controllers</p>

<p>object Action extends ActionBuilder[Request] {
  def invokeBlock<a href="request:%20Request[A],%20block:%20(Request[A]">A</a> => Future[SimpleResult]) = {</p>

<pre><code>block(request)
</code></pre>

<p>  }</p>

<p>  /<em>*
   * The standard [[play.api.mvc.Action]] loses the MDC context.
   *
   * This action builder sets the [[ExecutionContext]] so that the
   * MDC context is propagated.
   * With this custom [[ExecutionContext]], the request and the correlation IDs
   * can be logged.
   </em>/
  override def executionContext: ExecutionContext = Execution.defaultContext
}
```</p>

<p>Instead of using of <code>play.api.mvc.Action</code>, we just have to use the newly defined <code>controllers.Action</code>.</p>

<p>With each of these customizations, we are now able to use the Mapped Diagnostic Context (MDC) with asynchronous actions written in Scala.</p>
]]></content>
  </entry>
  
</feed>
